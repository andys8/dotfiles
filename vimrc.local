" Vim configuration

scriptencoding utf-8
set relativenumber
set confirm
set shell=/bin/bash
set shortmess+=c
set nobackup
set nowritebackup
set noswapfile
set signcolumn=yes

set termguicolors
set t_Co=256
let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"

" updatetime has performance impact
set updatetime=300

" timouts regarding keys
set timeoutlen=500
set ttimeoutlen=50

set lazyredraw
set scrolljump=3
set synmaxcol=300
syntax sync minlines=256

" Allow project-specific .vimrc files
set exrc
set secure

" gvim
set guioptions=c
set guifont=Iosevka\ Nerd\ Font\ 14
let g:nerdtree_tabs_open_on_gui_startup = 0

" Switch themes
command Dracula colorscheme dracula    | AirlineTheme dracula | set nocursorline | silent! e
command Nord    colorscheme nord       | AirlineTheme nord    | set nocursorline | silent! e
command Dark    colorscheme torte      | AirlineTheme dark    | set nocursorline | silent! e
command Light   colorscheme shirotelin | AirlineTheme dark    | set cursorline   | silent! e

" Theme
let g:dracula_colorterm = 1
let g:dracula_italic = 1
colorscheme dracula

" Airline
let g:airline_theme = 'dracula'
let g:airline_extensions = ['branch', 'coc', 'tabline', 'quickfix']
let g:airline_highlighting_cache = 1
let g:airline_powerline_fonts = 1
let g:airline_skip_empty_sections = 0
let g:airline#extensions#coc#error_symbol = '  '
let g:airline#extensions#coc#warning_symbol = ' '
let g:airline#extensions#branch#vcs_priority = ["git"]
let g:airline#extensions#branch#vcs_checks = []

" Ignore files
set wildignore+=*/node_modules/*,*/.stack-work/*,*/.stack/*

" Copy command
vnoremap <C-x> :!pbcopy<CR>
vnoremap <C-c> :w !pbcopy<CR><CR>

" Tab is the same as <C-i> and should jump forward
nunmap <Tab>

" Paste multiple times
xnoremap p "_dP

" Exit insert mode
inoremap jj <ESC>

" Save
nnoremap <C-s> :w<CR>
inoremap <C-s> <ESC>:w<CR>

" Saves the file (handling the permission-denied error)
cnoremap w!! w !sudo tee % >/dev/null

" Date
inoremap <C-d> <C-R>=strftime("%Y-%m-%d")<CR>
cnoremap <C-d> <C-R>=strftime("%Y-%m-%d")<CR>

" Open links in browser
let g:netrw_nogx = 1
let g:openbrowser_browser_commands = [
  \ {"name": "xdg-open", "args": "qutebrowser {uri} \&" }
\]
nmap gx <Plug>(openbrowser-smart-search)
vmap gx <Plug>(openbrowser-smart-search)

" Expand snippets
let g:UltiSnipsExpandTrigger='<c-j>'

" Multiple cursors
let g:multi_cursor_exit_from_visual_mode = 1
let g:multi_cursor_exit_from_insert_mode = 1
let g:multi_cursor_start_word_key = '<C-n>'
let g:multi_cursor_select_all_word_key = '<leader><C-n>'

" Multiple cursor fix for delimitmate issue with '"' char
function! Multiple_cursors_before()
    exe 'DelimitMateOff'
endfunction

function! Multiple_cursors_after()
    exe 'DelimitMateOn'
endfunction

" Elm
let g:polyglot_disabled = ['elm']

" List toggle
let g:lt_location_list_toggle_map = '<leader>l'
let g:lt_quickfix_list_toggle_map = '<leader>ö'

" Ctags
set tags+=tags;tags.vendors;,tags;

" Search with Rg (overwrites vimrc)
nnoremap <silent> <Leader>f :Rg<CR>
nnoremap <silent> <leader>F :Rgrep<CR>
" Rg will ignore filenames
command! -bang -nargs=* Rg
      \ call fzf#vim#grep(
      \ 'rg --column --line-number --no-heading --color=always --glob=!package-lock.json --smart-case '.shellescape(<q-args>),
      \ 1,
      \ {'options': '--delimiter : --nth 2..'},
      \ <bang>0)

" Zen mode / goyo
nnoremap <F6> :Goyo<CR>

" Command to read windows files (crlf)
abbrev windowsfile e ++ff=dos
abbrev dosfile e ++ff=dos

" Startify
let g:startify_files_number = 5
let g:startify_change_to_dir = 0
let startify_custom_header = split(system('toilet -f pagga " VIM Editor"'), '\n')

let g:startify_lists = [
      \ {'type': 'files', 'header': ['   Recently']},
      \ {'type': 'commands', 'header': ['   Commands']},
      \ {'type': 'bookmarks', 'header': ['   Bookmarks']},
      \ ]

let g:startify_commands = [
      \ {'o': ['Open (file)', ':FZF']},
      \ {'f': ['Find (text in file)', ':Rg']},
      \ ]

let g:startify_bookmarks = [
      \ {'d': '~/dotfiles'},
      \ {'v': '~/dotfiles/vimrc.local'},
      \ {'n': '~/dotfiles/nix/packages.nix'},
      \ ]

" Rooter
let g:rooter_silent_chdir = 1
let g:rooter_patterns = [
      \ 'package.json',
      \ 'elm.json',
      \ 'stack.yaml',
      \ '.git/',
      \ 'pom.xml',
      \ 'requirements.txt'
      \ ]

" Coc
let g:coc_node_path = "~/.nix-profile/bin/node"
let g:coc_global_extensions = [
      \ 'coc-cspell-dicts',
      \ 'coc-diagnostic',
      \ 'coc-docker',
      \ 'coc-eslint',
      \ 'coc-java',
      \ 'coc-json',
      \ 'coc-markdownlint',
      \ 'coc-metals',
      \ 'coc-prettier',
      \ 'coc-spell-checker',
      \ 'coc-tslint-plugin',
      \ 'coc-tsserver',
      \ 'coc-ultisnips',
      \ 'coc-vetur',
      \ 'coc-yaml'
      \ ]

nnoremap <F5> :CocRebuild<CR>
nmap <leader>r <Plug>(coc-rename)
nmap <leader>R <Plug>(coc-refactor)
nmap <silent> <leader>s <Plug>(coc-codeaction)
nmap <silent> <leader>S <Plug>(coc-fix-current)
nmap <silent> <leader>a <Plug>(coc-diagnostic-next)
nmap <silent> <leader>A <Plug>(coc-diagnostic-next-error)
nmap <silent> <leader>d <Plug>(coc-definition)
nmap <silent> K         :call CocAction('doHover')<CR>
nmap <silent> <leader>g :call CocAction('doHover')<CR>
nmap <silent> <leader>G <Plug>(coc-diagnostic-info)
nmap <silent> <leader>t <Plug>(coc-type-definition)
nmap <silent> <leader>u <Plug>(coc-references)
nmap <silent> <leader>i <Plug>(coc-implementation)
nmap <silent> <leader>p :call CocActionAsync('format')<CR>
xmap <silent> <leader>p <Plug>(coc-format-selected)
nnoremap <silent> <leader>O :call CocAction('runCommand', 'editor.action.organizeImport')<CR>

function! s:check_back_space() abort
  let col = col('.') - 1
  return !col || getline('.')[col - 1]  =~# '\s'
endfunction

inoremap <silent><expr> <c-space> coc#refresh()
inoremap <silent><expr> <TAB> pumvisible() ? "\<C-n>" : <SID>check_back_space() ? "\<TAB>" : coc#refresh()
inoremap <expr> <cr> pumvisible() ? "\<C-y>" : "\<C-g>u\<CR>"
inoremap <expr><S-TAB> pumvisible() ? "\<C-p>" : "\<C-h>"

" Coc Errors
hi link CocErrorHighlight SpellBad
hi link CocWarningHighlight SpellLocal
hi link CocInfoHighlight SpellRare
hi link CocHintHighlight SpellCap

" Floating
hi link CocFloating Visual
hi link CocErrorFloat Visual
hi link CocWarningFloat Visual
hi link CocInfoFloat Visual
hi link CocHintFloat Visual

" Pmenu (e.g. completions)
hi! link Pmenu Visual
hi! link PmenuSel ErrorMsg

" Java
let g:syntastic_java_checkers = []
command! -nargs=0 IdeaFormat silent :w | exec "!idea format %" | :e

" vimdiff
if &diff
  map <leader>1 :diffget LOCAL<CR>
  map <leader>2 :diffget BASE<CR>
  map <leader>3 :diffget REMOTE<CR>
  map <leader>g :diffget<CR>
  map <leader>d :difft<CR>
  map <leader>o :diffo<CR>
endif

" Git gutter
let g:gitgutter_sign_priority = 1
let g:gitgutter_sign_added = '✚'
let g:gitgutter_sign_modified = '➜'
let g:gitgutter_sign_removed = '✘'
let g:gitgutter_sign_removed_first_line = '✘'
let g:gitgutter_sign_modified_removed='±'
let g:gitgutter_preview_win_floating = 1

command! -nargs=0 GitUndo :GitGutterUndoHunk

nmap <silent> <leader>m :call GitGutterNextHunkCycle()<CR>
nmap <silent> <leader>M :GitGutterPreviewHunk<CR>

function! GitGutterNextHunkCycle()
  let line = line('.')
  silent! GitGutterNextHunk
  if line('.') == line
    normal! 1G
    GitGutterNextHunk
  endif
endfunction

" git: Do not remember commit message cursor position
autocmd BufReadPost COMMIT_EDITMSG exe "normal! gg"

" NerdTree
let g:NERDTreeMinimalUI = 1
nmap <silent> <leader>n :NERDTreeToggle<CR>
nmap <silent> <leader>N :NERDTreeFind<CR>
hi link NERDTreeOpenable Type
hi link NERDTreeClosable Special
hi link NERDTreeDir Question

" Folding
set foldmethod=indent
set foldnestmax=1
set nofoldenable
set foldlevel=0
noremap <leader>z zM<CR>
noremap <leader>Z zR<CR>

" haskell
augroup haskellrename
  au!
  au FileType haskell nmap <buffer> <leader>r <Plug>CtrlSFCwordExec
  au FileType haskell vmap <buffer> <leader>r <Plug>CtrlSFVwordExec
augroup END

" haskell: Alex, Happy
au BufRead,BufNewFile *.x set filetype=alex
au BufRead,BufNewFile *.y set filetype=happy
au BufWritePre *.hs call CocAction('format')

" Qutebrowser
au BufRead,BufNewFile qutebrowser-editor-* set filetype=text

" Ranger
let g:ranger_map_keys = 0
nmap <leader>o :Ranger<CR>

" Presenting
let g:presenting_top_margin = 2

" Markdown
let g:vim_markdown_conceal = 1
let g:vim_markdown_conceal_code_blocks = 1
